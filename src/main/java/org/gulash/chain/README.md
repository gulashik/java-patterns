# Chain of Responsibility (Цепочка обязанностей)

## Суть паттерна
**Chain of Responsibility** — это поведенческий паттерн проектирования, который позволяет передавать запросы последовательно по цепочке обработчиков. Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепочке.

## Мотивация
В сложных системах один и тот же запрос может требовать различных типов проверок или обработки (логирование, аутентификация, валидация, кеширование). Если объединить всё это в один метод или класс, он станет перегруженным («Божественный объект»), трудным для тестирования и расширения.

**Chain of Responsibility решает эти проблемы:**
1.  **Разделение ответственности:** каждый обработчик фокусируется на одной задаче (Single Responsibility Principle).
2.  **Гибкость:** вы можете динамически изменять порядок обработчиков или добавлять новые, не меняя код существующих.
3.  **Слабая связанность:** отправитель запроса не знает, какой именно объект в итоге обработает запрос.

## Структура примера
В данном примере реализован конвейер обработки HTTP-запроса:
1.  `Request` — модель данных запроса.
2.  `Handler` — базовый абстрактный класс, определяющий интерфейс обработки и механизм связи.
3.  `AuthHandler` — проверяет наличие и валидность токена.
4.  `RoleCheckHandler` — проверяет права доступа (RBAC).
5.  `ValidationHandler` — проверяет корректность тела запроса.

## Подводные камни и Best Practices

### Подводные камни
*   **Запрос может остаться необработанным:** если ни один обработчик не взял на себя ответственность и цепочка закончилась, запрос может просто «исчезнуть». Всегда стоит иметь «заглушку» в конце или логику по умолчанию.
*   **Сложность отладки:** бывает трудно отследить путь запроса через длинную цепочку, особенно если она строится динамически.
*   **Зацикливание:** при неправильной конфигурации (особенно если цепочка строится вручную в коде) можно создать циклическую зависимость.

### Best Practices
*   **Используйте интерфейсы/абстрактные классы:** это позволит легко подменять реализации.
*   **Прерывание цепочки:** решите, должен ли запрос идти дальше после успешной обработки (как в Middleware) или обработка должна прекратиться (как в обработчиках событий GUI).
*   **Компоновка через DI:** в современных фреймворках (Spring, Micronaut) цепочки часто собираются автоматически через список бинов одного типа.

## Когда использовать
*   Когда программа должна обрабатывать разнообразные запросы несколькими способами, но заранее неизвестно, какие конкретно запросы будут приходить и какие обработчики для них понадобятся.
*   Когда важно выполнять несколько обработчиков строго в определенном порядке.
*   Когда набор объектов, способных обработать запрос, должен задаваться динамически.
