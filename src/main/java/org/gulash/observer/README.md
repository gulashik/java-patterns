# Паттерн Наблюдатель (Observer)

## Суть паттерна
**Наблюдатель** — это поведенческий паттерн проектирования, который создаёт механизм подписки, позволяющий одним объектам следить и реагировать на события, происходящие в других объектах.

Система обычно состоит из двух типов объектов:
1.  **Субъект (Subject/Publisher)** — объект, обладающий интересным состоянием. Он хранит список подписчиков и уведомляет их при изменениях.
2.  **Наблюдатель (Observer/Subscriber)** — интерфейс, который реализуют объекты, желающие получать уведомления.

## Мотивация
Представьте, что у вас есть магазин и клиент. Клиент хочет знать, когда в магазин поступит новый iPhone. 
- **Плохое решение (Polling):** Клиент каждый день ходит в магазин и проверяет наличие. Это тратит ресурсы клиента и время продавца.
- **Решение с Наблюдателем:** Магазин ведет список заинтересованных клиентов. Как только iPhone поступает, магазин сам рассылает уведомления всем из списка.

## Реализация в примере
- `Subject` — интерфейс издателя (методы `subscribe`, `unsubscribe`, `notifyObservers`).
- `Observer` — интерфейс наблюдателя (метод `update`).
- `NewsAgency` — конкретный издатель, который "рассылает новости".
- `NewsChannel` — конкретный наблюдатель, который "печатает новости" при получении.

## Подводные камни (Pitfalls)
1.  **Утечки памяти (Lapsed Listener Problem):** Если наблюдатель не отпишется от издателя, он не будет удален сборщиком мусора (GC), так как издатель хранит на него ссылку. 
    - *Best Practice:* Использовать `WeakReference` для хранения наблюдателей или строго следить за жизненным циклом (отписываться в `onDestroy` / `close`).
2.  **Порядок уведомлений:** Паттерн обычно не гарантирует порядок, в котором наблюдатели получат уведомления.
3.  **Производительность:** Если наблюдателей очень много, а уведомления происходят часто, это может замедлить работу основного потока издателя.
4.  **Циклические зависимости:** Если Наблюдатель А подписан на Б, а Б подписан на А, и они уведомляют друг друга в ответ на `update`, возникнет бесконечный цикл или StackOverflow.

## Best Practices
- **Пустой интерфейс или generic:** В Java часто используют дженерики для передачи данных разного типа.
- **Push vs Pull модель:**
    - *Push:* Издатель передает все данные вместе с уведомлением (наш пример).
    - *Pull:* Издатель уведомляет, что что-то изменилось, а Наблюдатель сам запрашивает нужные ему данные у Издателя.
- **Thread Safety:** В многопоточной среде список наблюдателей должен быть защищен (например, `CopyOnWriteArrayList`).

## Сравнение с похожими паттернами
### 1. Наблюдатель vs Посредник (Mediator)
- **Observer:** Связь "один ко многим". Издатель не знает, кто на него подписан и зачем. Наблюдатели реагируют на изменение состояния.
- **Mediator:** Устраняет прямые связи между множеством компонентов, заставляя их общаться через один объект-посредник. Цель — уменьшить хаос в связях.

### 2. Наблюдатель vs Издатель-Подписчик (Pub/Sub)
Часто их путают, но в классическом Pub/Sub есть **Event Bus** (брокер) — промежуточное звено.
- **Observer:** Издатель напрямую знает о подписчиках (хранит их список).
- **Pub/Sub:** Издатель отправляет сообщение в "канал" (Topic), а подписчики слушают этот канал. Они не знают друг о друге вообще.

### 3. Наблюдатель vs Состояние (State)
- **Observer:** Наблюдатели реагируют на изменение состояния *извне*.
- **State:** Объект меняет свое *поведение* в зависимости от внутреннего состояния.