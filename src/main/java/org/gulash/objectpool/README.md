# Generic Object Pool Implementation

Библиотека на Java, реализующая паттерн проектирования «Пул объектов» (Object Pool). Пул позволяет повторно использовать ресурсоемкие объекты (например, соединения с БД), минимизируя затраты на их создание и уничтожение.

## Суть проекта

Пул объектов управляет жизненным циклом ограниченного набора ресурсов. Основные возможности:
- **Потокобезопасность**: поддержка конкурентного доступа из множества потоков.
- **Eager Initialization**: создание минимального набора объектов при запуске.
- **On-demand Creation**: создание новых объектов при нехватке, до достижения лимита.
- **Валидация**: проверка работоспособности объекта перед выдачей.
- **Тайм-ауты**: ожидание свободного ресурса в течение заданного времени.
- **Статистика**: мониторинг производительности и нагрузки на пул.

---

## Структура классов

Проект разделен на логические блоки: интерфейсы управления, конкретные реализации, фабрики и вспомогательные утилиты.

### 1. Пул объектов (`org.gulash.objectpool.pool`)
- `ItemPool<T>` (Interface): Основной контракт пула. Методы `acquire(timeout)` для получения объекта, `release(obj)` для возврата и `getStatistics()`.
- `BlockingItemPool<T>`: Основная реализация на базе `BlockingQueue`. Использует `Atomic` переменные для учета размеров и `ConcurrentHashMap` для отслеживания выданных объектов.

### 2. Фабрики (`org.gulash.objectpool.factory`)
- `ItemFactory<T>` (Interface): Определяет, как создавать, проверять (`validate`), очищать (`reset`) и уничтожать (`destroy`) объекты пула.
- `DatabaseConnectionFactory`: Реализация фабрики для создания имитаций соединений с БД.

### 3. Объекты ресурсов (`org.gulash.objectpool.factory.item`)
- `DatabaseConnection`: Пример «дорогого» объекта.
    - Реализует `AutoCloseable`, но метод `close()` переопределен так, чтобы возвращать объект обратно в пул, а не закрывать соединение физически.
    - Метод `destroy()` выполняет реальное закрытие ресурсов.

### 4. Утилиты (`org.gulash.objectpool.pool.util`)
- `PoolStatistics`: Immutable-объект, содержащий метрики: текущий размер, количество свободных/занятых объектов, счетчик тайм-аутов и среднее время ожидания.

---

## Как это работает (Workflow)

1. **Инициализация**: Создается `BlockingItemPool` с указанием `minSize` и `maxSize`. Сразу создается `minSize` объектов.
2. **Запрос (Acquire)**:
    - Пул пытается взять объект из очереди.
    - Если очередь пуста и `currentSize < maxSize`, создается новый объект.
    - Если лимит достигнут, поток ждет освобождения объекта в течение `timeout`.
3. **Валидация**: Перед выдачей объект проверяется через `factory.validate()`. Если он «протух», он уничтожается, и пул пробует выдать другой.
4. **Использование**: Клиент использует объект (желательно в блоке `try-with-resources`).
5. **Возврат (Release)**: Метод `close()` объекта (или явный вызов `pool.release()`) возвращает объект в пул. Перед этим вызывается `factory.reset()` для очистки состояния объекта.

---

## Пример использования

```java
// 1. Создаем фабрику для объектов
DatabaseConnectionFactory factory = new DatabaseConnectionFactory("localhost", 5432);

// 2. Инициализируем пул: minSize=2, maxSize=5
try (ItemPool<DatabaseConnection> pool = new BlockingItemPool<>(factory, 2, 5)) {
    
    // 3. Получаем объект из пула (используем try-with-resources для авто-возврата)
    try (DatabaseConnection conn = pool.acquire()) {
        // 4. Используем объект
        String result = conn.executeQuery("SELECT * FROM users");
        System.out.println(result);
        
        // Мониторинг состояния
        System.out.println(pool.getStatistics());
    } 
    // Объект автоматически возвращается в пул при закрытии ресурса
}
```


