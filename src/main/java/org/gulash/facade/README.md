# Паттерн Фасад (Facade)

## Суть паттерна

**Фасад** — это структурный паттерн проектирования, который предоставляет простой интерфейс к сложной системе классов,
библиотеке или фреймворку.

Вместо того чтобы заставлять клиентский код работать с десятками специализированных объектов подсистемы, Фасад
предлагает один упрощенный объект, который берет на себя координацию работы этих объектов.

## Мотивация (Зачем это нужно?)

1. **Упрощение использования:** Когда система становится слишком сложной или содержит много зависимых классов, Фасад
   предоставляет "точку входа", скрывая детали реализации.
2. **Изоляция (Слабая связанность):** Клиенты зависят только от Фасада, а не от множества классов подсистемы. Это
   позволяет изменять или заменять компоненты подсистемы, не затрагивая клиентский код.
3. **Упорядочивание хаоса:** Помогает структурировать код, разделяя его на слои. Например, можно создать фасад для
   каждого уровня (layer) системы.

## Основные компоненты

* **Facade (VideoConversionFacade):** Знает, каким классам подсистемы нужно переадресовать запрос и как их правильно
  скомбинировать.
* **Дополнительный Фасад (опционально):** Можно создавать несколько фасадов для разных групп функций, чтобы сам фасад не
  превратился в "Божественный объект" (God Object).
* **Сложная подсистема (Complex Subsystem):** Набор классов (VideoFile, Codec, BitrateReader и т.д.), которые выполняют
  реальную работу. Они не знают о существовании фасада.

## Best Practices (Лучшие практики)

* **Принцип наименьшей осведомленности (Закон Деметры):** Клиент должен общаться только с "друзьями" (Фасадом), а не с "
  друзьями друзей" (внутренними классами подсистемы).
* **Доступность подсистемы:** Фасад не должен закрывать доступ к подсистеме. Если клиенту нужны расширенные функции, он
  все еще может работать с классами подсистемы напрямую.
* **Тонкий фасад:** Фасад должен только перенаправлять вызовы, а не содержать сложную бизнес-логику сам по себе.

## Подводные камни

* **God Object:** Есть риск превратить фасад в огромный класс, который знает слишком много обо всем в системе.
* **Скрытие полезного функционала:** Если фасад слишком сильно упрощает интерфейс, разработчикам может не хватать
  гибкости подсистемы.

## Сравнение с похожими паттернами

| Паттерн              | Сходство                         | Отличие                                                                                                                                     |
|:---------------------|:---------------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------|
| **Adapter**          | Оба оборачивают объекты.         | **Adapter** меняет интерфейс, чтобы сделать его совместимым. **Facade** упрощает интерфейс.                                                 |
| **Proxy**            | Оба стоят "перед" объектом.      | **Proxy** имеет тот же интерфейс, что и реальный объект, и контролирует доступ к нему. **Facade** создает новый упрощенный интерфейс.       |
| **Mediator**         | Оба централизуют взаимодействие. | **Mediator** координирует общение *между* объектами подсистемы (они знают о посреднике). В **Facade** объекты подсистемы не знают о фасаде. |
| **Abstract Factory** | Могут использоваться вместе.     | Можно использовать Abstract Factory для создания объектов подсистемы внутри Фасада, скрывая их конфигурацию.                                |

## Пример реализации

В данном проекте представлен пример конвертации видео. Для пользователя этот процесс выглядит как один вызов
`convertVideo()`, но внутри задействованы:

* Распознавание формата (`CodecFactory`)
* Чтение битрейта (`BitrateReader`)
* Смешивание аудио (`AudioMixer`)
* Работа с файлами и кодеками.
