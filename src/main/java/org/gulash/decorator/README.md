# Паттерн Декоратор (Decorator)

## Суть паттерна
**Декоратор** — это структурный паттерн проектирования, который позволяет динамически добавлять объектам новые обязанности, оборачивая их в объекты-обертки.

Вместо того чтобы расширять функциональность класса через наследование (статически), вы используете композицию, "оборачивая" объект в другой объект того же типа. Это позволяет создавать цепочки объектов, где каждый слой добавляет свое поведение.

## Мотивация (Зачем это нужно?)
1. **Преодоление ограничений наследования**: Наследование происходит на этапе компиляции. Вы не можете изменить поведение объекта в рантайме. Кроме того, Java не поддерживает множественное наследование, что делает создание классов со всеми комбинациями свойств невозможным (проблема "взрывного роста иерархии").
2. **Принцип единственной ответственности (SRP)**: Вместо того чтобы перегружать один класс всеми возможными функциями, вы разделяете их на мелкие части-декораторы.
3. **Гибкость**: Вы можете комбинировать декораторы в любом порядке и составе прямо во время выполнения программы.

## Пример реализации (Система уведомлений)
В данном примере (`org.gulash.decorator`):
- `Notifier` (интерфейс) — определяет базовый метод `send()`.
- `EmailNotifier` (компонент) — базовая реализация, отправляющая email.
- `BaseNotifierDecorator` (базовый декоратор) — содержит ссылку на обернутый объект (`wrapper`).
- `SmsDecorator`, `SlackDecorator` (конкретные декораторы) — добавляют отправку SMS и сообщений в Slack соответственно.

## Подводные камни и Best Practices
1. **Порядок имеет значение**: Если декораторы зависят друг от друга, их порядок в цепочке важен. Например, декоратор шифрования должен идти *после* декоратора сжатия, иначе вы будете сжимать зашифрованные данные (что неэффективно).
2. **Трудность настройки**: Чем больше слоев в "пироге", тем сложнее его инициализировать. Для решения этой проблемы часто используют паттерны **Фабрика** или **Строитель**.
3. **Проблема идентификации**: Декорированный объект — это *другой* объект. Если вы полагаетесь на проверку типов (`instanceof`) или ссылки на конкретные реализации, декоратор может все сломать.
4. **Интерфейс должен быть стабильным**: Декоратор должен максимально точно повторять интерфейс оборачиваемого объекта.

## Сравнение с другими паттернами
- **Proxy (Заместитель)**: Похож по структуре, но преследует другую цель. Прокси управляет доступом к объекту (ленивая инициализация, контроль прав), а Декоратор расширяет функциональность.
- **Adapter (Адаптер)**: Адаптер меняет интерфейс объекта, чтобы он стал совместим с другим. Декоратор сохраняет интерфейс прежним или расширяет его, оставаясь совместимым.
- **Chain of Responsibility (Цепочка обязанностей)**: В цепочке запрос передается от одного обработчика к другому, пока кто-то его не обработает. В декораторе запрос проходит через *все* слои.
